/* Interface between GCC C++ FE and GDB  -*- c -*-

   Copyright (C) 2014-2016 Free Software Foundation, Inc.

   This file is part of GCC.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */



/* Push namespace NAME as the current binding level, to which
   newly-introduced decls will be bound.  An empty string identifies
   the global namespace, whereas NULL identifies an anonymous
   namespace.  A namespace named NAME is created in the current scope,
   if needed.

   If the newly-created namespace is to be an inline namespace, after
   push_namespace, get the nested namespace decl with
   get_current_binding_level, pop back to the enclosing namespace,
   call using_namespace with INLINE_P, and then push to the inline
   namespace again.  */

GCC_METHOD1 (int /* bool */, push_namespace,
	     const char *)	      /* Argument NAME.  */

/* Pop the namespace last entered with push_namespace, restoring the
   binding level in effect before the matching push_namespace.  */

GCC_METHOD0 (int /* bool */, pop_namespace)

/* Return the NAMESPACE_DECL, TYPE_DECL or FUNCTION_DECL of the
   current binding level.  */

GCC_METHOD0 (gcc_decl, get_current_binding_level)

/* Add USED_NS to the namespaces used by the current binding level.
   Use get_current_binding_level to obtain USED_NS's gcc_decl.
   INLINE_P indicates USED_NS was declared as an inline namespace, or
   the presence of attribute strong in the using directive, which
   is an older but equivalent GCC extension.  */

GCC_METHOD2 (int /* bool */, using_namespace,
	     gcc_decl,			/* Argument USED_NS.  */
	     int /* bool */)		/* Argument INLINE_P.  */

/* Introduce a namespace alias declaration, as in:

   namespace foo = [... ::] bar;

   After this call, namespace TARGET will be visible as ALIAS within
   the current namespace.  Get the declaration for TARGET by calling
   get_current_binding_level after pushing into it.  */

GCC_METHOD2 (int /* bool */, new_namespace_alias,
	     const char *,		/* Argument ALIAS.  */
	     gcc_decl)			/* Argument TARGET.  */

/* Introduce a using declaration, as in:

   using foo::bar;

   The TARGET decl names the qualifying scope (foo:: above) and the
   identifier (bar), but that does not mean that only TARGET will be
   brought into the current scope: all bindings of TARGET's identifier
   in the qualifying scope will be brought in.

   FLAGS should specify GCC_CP_SYMBOL_USING.  If the current scope is
   a class scope, visibility flags must be supplied.

   Even when TARGET is template dependent, we don't need to specify
   whether or not it is a typename: the supplied declaration (that
   could be a template-dependent type converted to declaration by
   type_decl) indicates so.  */

GCC_METHOD2 (int /* bool */, new_using_decl,
	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
	     gcc_decl)		      /* Argument TARGET.  */

/* Create a new "decl" in GCC, and bind it in the current binding
   level.  A decl is a declaration, basically a kind of symbol.

   NAME is the name of the new symbol.  SYM_KIND is the kind of
   symbol being requested.  SYM_TYPE is the new symbol's C++ type;
   except for labels, where this is not meaningful and should be
   zero.  If SUBSTITUTION_NAME is not NULL, then a reference to this
   decl in the source will later be substituted with a dereference
   of a variable of the given name.  Otherwise, for symbols having
   an address (e.g., functions), ADDRESS is the address.  FILENAME
   and LINE_NUMBER refer to the symbol's source location.  If this
   is not known, FILENAME can be NULL and LINE_NUMBER can be 0.
   This function returns the new decl.

   Use this function to register typedefs, functions and variables to
   namespace and local binding levels, and typedefs, member functions
   (static or not), and static data members to class binding levels.
   Note that, since access controls are disabled, we have no means to
   express private, protected and public.

   There are various flags that can be set in SYM_KIND to specify
   additional semantics.  Look for GCC_CP_FLAGs in the definition of
   enum gcc_cp_symbol_kind in gcc-cp-interface.h.

   In order to define member functions, pass GCC_CP_SYMBOL_FUNCTION in
   SYM_KIND, and a function_type for static member functions or a
   method type for non-static member functions, including constructors
   and destructors.  Use build_function_type to create a function
   type; for a method type, start by creating a function type without
   any compiler-introduced artificial arguments (the implicit this
   pointer, and the __in_chrg added to constructors and destructors,
   and __vtt_parm added to the former), and then use build_method_type
   to create the method type out of the class type and the function
   type.

   For operator functions, set GCC_CP_FLAG_SPECIAL_FUNCTION in
   SYM_KIND, in addition to any other applicable flags, and pass as
   NAME a string starting with the two-character mangling for operator
   name: "ps" for unary plus, "mL" for multiply and assign, *=; etc.
   Use "cv" for type converstion operators (the target type portion
   may be omitted, as it is taken from the return type in SYM_TYPE).
   For operator"", use "li" followed by the identifier (the mangled
   name mandates digits specifying the length of the identifier; if
   present, they determine the end of the identifier, otherwise, the
   identifier extents to the end of the string, so that "li3_Kme" and
   "li_Km" are equivalent).

   Constructors and destructors need special care, because for each
   constructor and destructor there may be multiple clones defined
   internally by the compiler.  With new_decl, you can introduce the
   base declaration of a constructor or a destructor, setting
   GCC_CP_FLAG_SPECIAL_FUNCTION the flag and using names starting with
   capital "C" or "D", respectively, followed by a digit (see below),
   a blank, or NUL ('\0').  DO NOT supply an ADDRESS or a
   SUBSTITUTION_NAME to new_decl, it would be meaningless (and
   rejected) for the base declaration; use define_cdtor_clone to
   introduce the address of each clone.  For constructor templates,
   declare the template with new_decl, and then, for each
   specialization, introduce it with specialize_function_template, and
   then define the addresses of each of its clones with
   define_cdtor_clone.

   NAMEs for GCC_CP_FLAG_SPECIAL_FUNCTION:

     NAME    meaning
     C?      constructor base declaration (? may be 1, 2, 4, blank or NUL)
     D?      destructor base declaration (? may be 0, 1, 2, 4, blank or NUL)
     nw      operator new
     na      operator new[]
     dl      operator delete
     da      operator delete[]
     ps      operator + (unary)
     ng      operator - (unary)
     ad      operator & (unary)
     de      operator * (unary)
     co      operator ~
     pl      operator +
     mi      operator -
     ml      operator *
     dv      operator /
     rm      operator %
     an      operator &
     or      operator |
     eo      operator ^
     aS      operator =
     pL      operator +=
     mI      operator -=
     mL      operator *=
     dV      operator /=
     rM      operator %=
     aN      operator &=
     oR      operator |=
     eO      operator ^=
     ls      operator <<
     rs      operator >>
     lS      operator <<=
     rS      operator >>=
     eq      operator ==
     ne      operator !=
     lt      operator <
     gt      operator >
     le      operator <=
     ge      operator >=
     nt      operator !
     aa      operator &&
     oo      operator ||
     pp      operator ++
     mm      operator --
     cm      operator ,
     pm      operator ->*
     pt      operator ->
     cl      operator ()
     ix      operator []
     qu      operator ?
     cv      operator <T> (conversion operator)
     li<id>  operator "" <id>

   FIXME: How about attributes; static_assert; lambdas?  */

GCC_METHOD7 (gcc_decl, new_decl,
	     const char *,	      /* Argument NAME.  */
	     enum gcc_cp_symbol_kind, /* Argument SYM_KIND.  */
	     gcc_type,		      /* Argument SYM_TYPE.  */
	     const char *,	      /* Argument SUBSTITUTION_NAME.  */
	     gcc_address,	      /* Argument ADDRESS.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Supply the ADDRESS of one of the multiple clones of constructor or
   destructor CDTOR.  The clone is selected using the following
   name mangling conventions:

     C1      in-charge constructor
     C2      not-in-charge constructor
     C4      unified constructor
     D0      deleting destructor
     D1      in-charge destructor
     D2      not-in-charge destructor
     D4      unified destructor

   The following information is not necessary to use the API.

   C1 initializes an instance of the class (rather than of derived
   classes), including virtual base classes, whereas C2 initializes a
   sub-object (of the given class type) of an instance of some derived
   class (or a full object that doesn't have any virtual base
   classes).

   D0 and D1 destruct an instance of the class, including virtual base
   classes, but only the former calls operator delete to release the
   object's storage at the end; D2 destructs a sub-object (of the
   given class type) of an instance of a derived class (or a full
   object that doesn't have any virtual base classes).

   The [CD]4 manglings (and symbol definitions) are non-standard, but
   GCC uses them in some cases: rather than assuming they are
   in-charge or not-in-charge, they test the implicit argument that
   the others ignore to tell how to behave.  These are defined in very
   rare cases of virtual inheritance and cdtor prototypes.  */

GCC_METHOD3 (gcc_decl, define_cdtor_clone,
	     const char *,	      /* Argument NAME.  */
	     gcc_decl,		      /* Argument CDTOR.  */
	     gcc_address)	      /* Argument ADDRESS.  */

/* Return the type associated with the given declaration.  This is
   most useful to obtain the type associated with a forward-declared
   class, because it is the gcc_type, rather than the gcc_decl, that
   has to be used to build other types, but new_decl returns a
   gcc_decl rather than a gcc_type.  This call can in theory be used
   to obtain the type from any other declaration; it is supposed to
   return the same type that was supplied when the declaration was
   created.  */

GCC_METHOD1 (gcc_type, decl_type,
	     gcc_decl)            /* Argument DECL.  */

/* Return the declaration for a type.  This is most useful to be able
   to pass a class to new_friend, since it expects a gcc_decl, but
   start_new_class_type and start_specialize_class_template return a
   gcc_type.  */

GCC_METHOD1 (gcc_decl, type_decl,
	     gcc_type)            /* Argument TYPE.  */

/* Declare DECL as a friend of the current class scope, if TYPE is
   NULL, or of TYPE itself otherwise.  DECL may be a function or a
   class, be they template generics, template specializations or not
   templates.  TYPE must be a class type (not a template generic).

   The new_friend call cannot introduce a declaration; even if the
   friend is first declared as a friend in the source code, the
   declaration belongs in the enclosing namespace, so it must be
   introduced in that namespace, and the resulting declaration can
   then be made a friend.

   DECL cannot, however, be a member of a template class generic,
   because we have no means to introduce their declarations.  This
   interface has no notion of definitions for template generics.  As a
   consequence, users of this interface must introduce each friend
   template member specialization separately, i.e., instead of:

     template <typename T> friend struct X<T>::M;

   they must be declared as if they were:

     friend struct X<onetype>::M;
     friend struct X<anothertype>::M;
     ... for each specialization of X.


   Specializations of a template can have each others' members as
   friends:

     template <typename T> class foo {
       int f();
       template <typename U> friend int foo<U>::f();
     };

   It wouldn't always be possible to define all specializations of a
   template class before introducing the friend declarations in their
   expanded, per-specialization form.

   In order to simplify such friend declarations, and to enable
   incremental friend declarations as template specializations are
   introduced, new_friend can be called after the befriended class is
   fully defined, passing it a non-NULL TYPE argument naming the
   befriended class type.  */

GCC_METHOD2 (int /* bool */, new_friend,
	     gcc_decl,		      /* Argument DECL.  */
	     gcc_type)		      /* Argument TYPE.  */

/* Return the type of a pointer to a given base type.  */

GCC_METHOD1 (gcc_type, build_pointer_type,
	     gcc_type)			/* Argument BASE_TYPE.  */

/* Return the type of a reference to a given base type.  */

GCC_METHOD2 (gcc_type, build_reference_type,
	     gcc_type,			/* Argument BASE_TYPE.  */
	     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */

/* Create a new pointer-to-member type.  MEMBER_TYPE is the data
   member type, while CLASS_TYPE is the class type containing the data
   member.  For pointers to member functions, MEMBER_TYPE must be a
   method type, and CLASS_TYPE must be specified even though it might
   be possible to extract it from the method type.  */

GCC_METHOD2 (gcc_type, build_pointer_to_member_type,
	     gcc_type,			   /* Argument CLASS_TYPE.  */
	     gcc_type) 			   /* Argument MEMBER_TYPE.  */

/* Start a template parameter list, so that subsequent
   build_template_typename_parm and build_template_value_parm calls
   create template parameters in the list.  The list is closed by a
   new_decl call with GCC_CP_SYMBOL_FUNCTION or GCC_CP_SYMBOL_CLASS,
   that, when the scope is a template parameter list, closes the
   parameter list and declares a template function or a template class
   with the parameter list.  */

GCC_METHOD0 (int /* bool */, start_new_template_decl)

/* Build a typename template-parameter (e.g., the T in template
   <typename T = X>).  Either PACK_P should be nonzero, to indicate an
   argument pack (the last argument in a variadic template argument
   list, as in template <typename... T>), or DEFAULT_TYPE may be
   non-NULL to set the default type argument (e.g. X) for the template
   parameter.  FILENAME and LINE_NUMBER may specify the source
   location in which the template parameter was declared.  */

GCC_METHOD5 (gcc_type, new_template_typename_parm,
	     const char *,			      /* Argument ID.  */
	     int /* bool */,			  /* Argument PACK_P.  */
	     gcc_type,			    /* Argument DEFAULT_TYPE.  */
	     const char *,			/* Argument FILENAME.  */
	     unsigned int)		     /* Argument LINE_NUMBER.  */

/* Build a template template-parameter (e.g., the T in template
   <template <[...]> class T = X>).  DEFAULT_TEMPL may be non-NULL to
   set the default type-template argument (e.g. X) for the template
   template parameter.  FILENAME and LINE_NUMBER may specify the
   source location in which the template parameter was declared.  */

GCC_METHOD5 (gcc_utempl, new_template_template_parm,
	     const char *,			      /* Argument ID.  */
	     int /* bool */,			  /* Argument PACK_P.  */
	     gcc_utempl,		   /* Argument DEFAULT_TEMPL.  */
	     const char *,			/* Argument FILENAME.  */
	     unsigned int)		     /* Argument LINE_NUMBER.  */

/* Build a value template-parameter (e.g., the V in template <typename
   T, T V> or in template <int V = X>).  DEFAULT_VALUE may be non-NULL
   to set the default value argument for the template parameter (e.g.,
   X).  FILENAME and LINE_NUMBER may specify the source location in
   which the template parameter was declared.  */

GCC_METHOD5 (gcc_decl, new_template_value_parm,
	     gcc_type,			  	    /* Argument TYPE.  */
	     const char *,			      /* Argument ID.  */
	     gcc_expr,			   /* Argument DEFAULT_VALUE.  */
	     const char *,			/* Argument FILENAME.  */
	     unsigned int)		     /* Argument LINE_NUMBER.  */

/* Build a template-dependent typename (e.g., typename T::bar or
   typename T::template bart<X>).  ENCLOSING_TYPE should be the
   template-dependent nested name specifier (e.g., T), ID should be
   the name of the member of the ENCLOSING_TYPE (e.g., bar or bart),
   and TARGS should be non-NULL and specify the template arguments
   (e.g. <X>) iff ID is to name a class template.

   In this and other calls, a template-dependent nested name specifier
   may be a template class parameter (new_template_typename_parm), a
   specialization (returned by new_dependent_typespec) of a template
   template parameter (returned by new_template_template_parm) or a
   member type thereof (returned by new_dependent_typename
   itself).  */

GCC_METHOD3 (gcc_type, new_dependent_typename,
	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
	     const char *,			      /* Argument ID.  */
	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */

/* Build a template-dependent class template (e.g., T::template bart).
   ENCLOSING_TYPE should be the template-dependent nested name
   specifier (e.g., T), ID should be the name of the class template
   member of the ENCLOSING_TYPE (e.g., bart).  */

GCC_METHOD2 (gcc_utempl, new_dependent_class_template,
	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
	     const char *)			      /* Argument ID.  */

/* Build a template-dependent template type specialization (e.g.,
   T<A>).  TEMPLATE_DECL should be a template template parameter
   (e.g., the T in template <template <[...]> class T = X>), and TARGS
   should specify the template arguments (e.g. <A>).  */

GCC_METHOD2 (gcc_type, new_dependent_typespec,
	     gcc_utempl,		   /* Argument TEMPLATE_DECL.  */
	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */

/* Build a template-dependent value expression (e.g., T::val or
   T::template f<X>).  ENCLOSING_TYPE should be the template-dependent
   nested name specifier (e.g., T), ID should be the name of the
   member of the ENCLOSING_TYPE (e.g., val or f), and TARGS should
   list template arguments (e.g. <X>) when f is to name a template
   function, or be NULL otherwise.  */

GCC_METHOD3 (gcc_decl, new_dependent_value_expr,
	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
	     const char *,			      /* Argument ID.  */
	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */

// FIXME: the above needs to support special member function names and
// overloaded operator names too.

/* Build a gcc_expr for the value VALUE in type TYPE.  */

GCC_METHOD2 (gcc_expr, literal_expr,
	     gcc_type,		  /* Argument TYPE.  */
	     unsigned long)	  /* Argument VALUE.  */

/* Build a gcc_expr that denotes DECL, the declaration of a variable
   or function in namespace scope, or of a static member variable or
   function.  */

GCC_METHOD1 (gcc_expr, decl_expr,
	     gcc_decl)		  /* Argument DECL.  */

/* Build a gcc_expr that denotes the unary operation UNARY_OP applied
   to the gcc_expr OPERAND.  */

GCC_METHOD2 (gcc_expr, unary_value_expr,
	     const char *,	  /* Argument UNARY_OP.  */
	     gcc_expr)		  /* Argument OPERAND.  */

/* Build a gcc_expr that denotes the binary operation BINARY_OP
   applied to gcc_exprs OPERAND1 and OPERAND2.  */

GCC_METHOD3 (gcc_expr, binary_value_expr,
	     const char *,	  /* Argument BINARY_OP.  */
	     gcc_expr,		  /* Argument OPERAND1.  */
	     gcc_expr)		  /* Argument OPERAND2.  */

/* Build a gcc_expr that denotes the ternary operation TERNARY_OP
   applied to gcc_exprs OPERAND1, OPERAND2 and OPERAND3.  */

GCC_METHOD4 (gcc_expr, ternary_value_expr,
	     const char *,	  /* Argument TERNARY_OP.  */
	     gcc_expr,		  /* Argument OPERAND1.  */
	     gcc_expr,		  /* Argument OPERAND2.  */
	     gcc_expr)		  /* Argument OPERAND3.  */

/* Build a gcc_expr that denotes the unary operation UNARY_OP applied
   to the gcc_type OPERAND, e.g., sizeof.  */

GCC_METHOD2 (gcc_expr, unary_type_expr,
	     const char *,	  /* Argument UNARY_OP.  */
	     gcc_type)		  /* Argument OPERAND.  */

/* Build a gcc_expr that denotes the binary operation BINARY_OP
   applied to gcc_type OPERAND1 and gcc_expr OPERAND2.  Use this for
   all kinds of type casts, and to form a pointer-to-member.  */

GCC_METHOD3 (gcc_expr, type_value_expr,
	     const char *,	  /* Argument BINARY_OP.  */
	     gcc_type,		  /* Argument OPERAND1.  */
	     gcc_expr)		  /* Argument OPERAND2.  */

/* FIXME: function call operations?  ctor/dtor?  new/delete?  */

/* Return the type of the gcc_expr OPERAND.
   Use this for decltype.

   Note: for template-dependent expressions, the result is NULL,
   because the type is only computed when template argument
   substitution is performed.  */

GCC_METHOD1 (gcc_type, expr_type,
	     gcc_expr)		  /* Argument OPERAND.  */

/* Introduce a specialization of a template function.

   TEMPLATE_DECL is the template function, and TARGS are the arguments
   for the specialization.  ADDRESS is the address of the
   specialization.  FILENAME and LINE_NUMBER specify the source
   location associated with the template function specialization.  */

GCC_METHOD5 (gcc_decl, specialize_function_template,
	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
	     const struct gcc_cp_template_args *,  /* Argument TARGS.  */
	     gcc_address,			 /* Argument ADDRESS.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Start defining a specialization of a template class, and enter its
   own binding level.  Initially it has no fields.

   TEMPLATE_DECL is the template class, and TARGS are the arguments
   for the specialization.  BASE_CLASSES indicate the base classes of
   class NAME.  FILENAME and LINE_NUMBER specify the source location
   associated with the template class specialization.  */

GCC_METHOD5 (gcc_type, start_specialize_class_template,
	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
	     const struct gcc_cp_template_args *,  /* Argument TARGS.  */
	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Create a new 'class' (or 'struct') type, record it in the current
   binding level, and enter its own binding level.  Initially it has
   no fields.

   NAME is the class name.  BASE_CLASSES indicate the base classes of
   class NAME.  FILENAME and LINE_NUMBER specify the source location
   associated with the class.  */

GCC_METHOD5 (gcc_type, start_new_class_type,
	     const char *,	      /* Argument NAME.  */
	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Create a new 'union' type, record it in the current binding level,
   and enter its own binding level.  Initially it has no fields.

   NAME is the union name.  FILENAME and LINE_NUMBER specify its
   source location.  */

GCC_METHOD4 (gcc_type, start_new_union_type,
	     const char *,	      /* Argument NAME.  */
	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Add a non-static data member to the most-recently-started
   unfinished struct or union type.  FIELD_NAME is the field's name.
   FIELD_TYPE is the type of the field.  BITSIZE and BITPOS indicate
   where in the struct the field occurs.  */

GCC_METHOD5 (int /* bool */, new_field,
	     const char *,		   /* Argument FIELD_NAME.  */
	     gcc_type,			   /* Argument FIELD_TYPE.  */
	     enum gcc_cp_symbol_kind,	   /* Argument FIELD_FLAGS.  */
	     unsigned long,		   /* Argument BITSIZE.  */
	     unsigned long)		   /* Argument BITPOS.  */

/* After all the fields have been added to a struct, class or union,
   the struct or union type must be "finished".  This does some final
   cleanups in GCC, and pops to the binding level that was in effect
   before the matching build_class_type or build_union_type.  */

GCC_METHOD1 (int /* bool */, finish_record_or_union,
	     unsigned long)		   /* Argument SIZE_IN_BYTES.  */

/* Create a new 'enum' type, and record it in the current binding
   level.  The new type initially has no associated constants.

   NAME is the enum name.  FILENAME and LINE_NUMBER specify its source
   location.  */

GCC_METHOD5 (gcc_type, start_new_enum_type,
	     const char *,	      /* Argument NAME.  */
	     gcc_type,		      /* Argument UNDERLYING_INT_TYPE. */
	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Add a new constant to an enum type.  NAME is the constant's name
   and VALUE is its value.  Returns a gcc_decl for the constant.  */

GCC_METHOD3 (gcc_decl, build_add_enum_constant,
	     gcc_type,		       /* Argument ENUM_TYPE.  */
	     const char *,	       /* Argument NAME.  */
	     unsigned long)	       /* Argument VALUE.  */

/* After all the constants have been added to an enum, the type must
   be "finished".  This does some final cleanups in GCC.  */

GCC_METHOD1 (int /* bool */, finish_enum_type,
	     gcc_type)		       /* Argument ENUM_TYPE.  */

/* Create a new function type.  RETURN_TYPE is the type returned by
   the function, and ARGUMENT_TYPES is a vector, of length NARGS, of
   the argument types.  IS_VARARGS is true if the function is
   varargs.  */

GCC_METHOD3 (gcc_type, build_function_type,
	     gcc_type,			   /* Argument RETURN_TYPE.  */
	     const struct gcc_type_array *,/* Argument ARGUMENT_TYPES.  */
	     int /* bool */)		   /* Argument IS_VARARGS.  */

/* Create a modified version of a function type that has default
   values for some of its arguments.  The returned type should ONLY be
   used to define functions or methods, never to declare parameters,
   variables, types or the like.

   DEFAULTS must have at most as many N_ELEMENTS as there are
   arguments without default values in FUNCTION_TYPE.  Say, if
   FUNCTION_TYPE has an argument list such as (T1, T2, T3, T4 = V0)
   and DEFAULTS has 2 elements (V1, V2), the returned type will have
   the following argument list: (T1, T2 = V1, T3 = V2, T4 = V0). */

GCC_METHOD2 (gcc_type, add_function_default_args,
	     gcc_type,			   /* Argument FUNCTION_TYPE.  */
	     const struct gcc_cp_function_default_args *)/* DEFAULTS.  */

/* Create a variant of a function type with an exception
   specification.  FUNCTION_TYPE is a function or method type.
   EXCEPT_TYPES is an array with the list of exception types.  Zero as
   the array length implies throw() AKA noexcept(true); NULL as the
   pointer to gcc_type_array implies noexcept(false), which is almost
   equivalent (but distinguishable by the compiler) to an unspecified
   exception list.  */

GCC_METHOD2 (gcc_type, build_exception_spec_variant,
	     gcc_type,			   /* Argument FUNCTION_TYPE.  */
	     const struct gcc_type_array *)/* Argument EXCEPT_TYPES.  */

/* Create a new non-static member function type.  FUNC_TYPE is the
   method prototype, without the implicit THIS pointer, added as a
   pointer to the QUALS-qualified CLASS_TYPE.  If CLASS_TYPE is NULL,
   this creates a cv-qualified (member) function type not associated
   with any specific class, as needed to support "typedef void f(int)
   const;", which can later be used to declare member functions and
   pointers to member functions.  */

GCC_METHOD4 (gcc_type, build_method_type,
	     gcc_type,			   /* Argument CLASS_TYPE.  */
	     gcc_type, 			   /* Argument FUNC_TYPE.  */
	     enum gcc_cp_qualifiers,	   /* Argument QUALS.  */
	     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */

/* Return an integer type with the given properties.  If BUILTIN_NAME
   is non-NULL, it must name a builtin integral type with the given
   signedness and size, and that is the type that will be returned.  */

GCC_METHOD3 (gcc_type, int_type,
	     int /* bool */,		   /* Argument IS_UNSIGNED.  */
	     unsigned long,                /* Argument SIZE_IN_BYTES.  */
	     const char *)		   /* Argument BUILTIN_NAME.  */

/* Return the 'char' type, a distinct type from both 'signed char' and
   'unsigned char' returned by int_type.  */

GCC_METHOD0 (gcc_type, char_type)

/* Return a floating point type with the given properties.  If BUILTIN_NAME
   is non-NULL, it must name a builtin integral type with the given
   signedness and size, and that is the type that will be returned.  */

GCC_METHOD2 (gcc_type, float_type,
	     unsigned long,                /* Argument SIZE_IN_BYTES.  */
	     const char *)		   /* Argument BUILTIN_NAME.  */

/* Return the 'void' type.  */

GCC_METHOD0 (gcc_type, void_type)

/* Return the 'bool' type.  */

GCC_METHOD0 (gcc_type, bool_type)

/* Return the std::nullptr_t type.  */

GCC_METHOD0 (gcc_type, get_nullptr_type)

/* Return the nullptr constant.  */

GCC_METHOD0 (gcc_expr, get_nullptr_constant)

/* Create a new array type.  If NUM_ELEMENTS is -1, then the array
   is assumed to have an unknown length.  */

GCC_METHOD2 (gcc_type, build_array_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     int)			  /* Argument NUM_ELEMENTS.  */

/* Create a new array type.  NUM_ELEMENTS is a template-dependent
   expression.  */

GCC_METHOD2 (gcc_type, build_dependent_array_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     gcc_expr)			  /* Argument NUM_ELEMENTS.  */

/* Create a new variably-sized array type.  UPPER_BOUND_NAME is the
   name of a local variable that holds the upper bound of the array;
   it is one less than the array size.  */

GCC_METHOD2 (gcc_type, build_vla_array_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     const char *)		  /* Argument UPPER_BOUND_NAME.  */

/* Return a qualified variant of a given base type.  QUALIFIERS says
   which qualifiers to use; it is composed of or'd together
   constants from 'enum gcc_cp_qualifiers'.  */

GCC_METHOD2 (gcc_type, build_qualified_type,
	     gcc_type,			      /* Argument UNQUALIFIED_TYPE.  */
	     enum gcc_cp_qualifiers)	      /* Argument QUALIFIERS.  */

/* Build a complex type given its element type.  */

GCC_METHOD1 (gcc_type, build_complex_type,
	     gcc_type)			  /* Argument ELEMENT_TYPE.  */

/* Build a vector type given its element type and number of
   elements.  */

GCC_METHOD2 (gcc_type, build_vector_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     int)			  /* Argument NUM_ELEMENTS.  */

/* Build a constant.  NAME is the constant's name and VALUE is its
   value.  FILENAME and LINE_NUMBER refer to the type's source
   location.  If this is not known, FILENAME can be NULL and
   LINE_NUMBER can be 0.  */

GCC_METHOD5 (int /* bool */, build_constant,
	     gcc_type,		  /* Argument TYPE.  */
	     const char *,	  /* Argument NAME.  */
	     unsigned long,	  /* Argument VALUE.  */
	     const char *,	  /* Argument FILENAME.  */
	     unsigned int)	  /* Argument LINE_NUMBER.  */

/* Emit an error and return an error type object.  */

GCC_METHOD1 (gcc_type, error,
	     const char *)		 /* Argument MESSAGE.  */
