/* Interface between GCC C++ FE and GDB  -*- c -*-

   Copyright (C) 2014-2015 Free Software Foundation, Inc.

   This file is part of GCC.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */



/* Push namespace NAME as the current binding level, to which
   newly-introduced decls will be bound.  An empty string identifies
   the global namespace, whereas NULL identifies an anonymous
   namespace.  A namespace named NAME is created in the current scope,
   if needed.  */

GCC_METHOD1 (int, push_namespace,
	     const char *)	      /* Argument NAME.  */

// FIXME: inline namespaces, anyone?

/* Pop the namespace last entered with push_namespace, restoring the
   binding level in effect before the matching push_namespace.  */

GCC_METHOD0 (int, pop_namespace)

/* Return the NAMESPACE_DECL, TYPE_DECL or FUNCTION_DECL of the
   current binding level.  */

GCC_METHOD0 (gcc_decl, get_current_binding_level)

/* Create a new "decl" in GCC, and bind it in the current binding
   level.  A decl is a declaration, basically a kind of symbol.

   NAME is the name of the new symbol.  SYM_KIND is the kind of
   symbol being requested.  SYM_TYPE is the new symbol's C++ type;
   except for labels, where this is not meaningful and should be
   zero.  If SUBSTITUTION_NAME is not NULL, then a reference to this
   decl in the source will later be substituted with a dereference
   of a variable of the given name.  Otherwise, for symbols having
   an address (e.g., functions), ADDRESS is the address.  FILENAME
   and LINE_NUMBER refer to the symbol's source location.  If this
   is not known, FILENAME can be NULL and LINE_NUMBER can be 0.
   This function returns the new decl.

   Use this function to register typedefs, functions and variables to
   namespace and local binding levels, and typedefs, member functions
   (static or not), and static data members to class binding levels.
   Note that, since access controls are disabled, we have no means to
   express private, protected and public.

   There are various flags that can be set in SYM_KIND to specify
   additional semantics.  Look for GCC_CP_FLAGs in the definition of
   enum gcc_cp_symbol_kind in gcc-cp-interface.h.

   In order to define member functions, pass GCC_CP_SYMBOL_FUNCTION in
   SYM_KIND, and a function_type for static member functions or a
   method type for non-static member functions, including constructors
   and destructors.  Use build_function_type to create a function
   type; for a method type, start by creating a function type without
   any compiler-introduced artificial arguments (the implicit this
   pointer, and the __in_chrg added to constructors and destructors,
   and __vtt_parm added to the former), and then use build_method_type
   to create the method type out of the class type and the function
   type.

   For constructors, destructors and operator functions, set
   GCC_CP_FLAG_SPECIAL_FUNCTION in SYM_KIND, in addition to any other
   applicable flags, and pass as NAME a string starting with the
   two-character mangling for the constructor or destructor variant
   (C1, C2, D0, D1, or D2, see below) or for the operator name: "ps"
   for unary plus, "mL" for multiply and assign, *=; etc.  Use "cv"
   for type converstion operators (the target type portion may be
   omitted, as it is taken from the return type in SYM_TYPE).  For
   operator"", use "li" followed by the identifier (the mangled name
   mandates digits specifying the length of the identifier; if
   present, they determine the end of the identifier, otherwise, the
   identifier extents to the end of the string, so that "li3_Kme" and
   "li_Km" are equivalent).

   Constructors and destructors need special care, since for each
   constructor prototype defined in the sources, two symbols are
   defined in the object code: C1 initializes an instance of the class
   (rather than of derived classes), including virtual base classes,
   whereas C2 initializes a sub-object (of the given class type) of an
   instance of some derived class (or a full object that doesn't have
   any virtual base classes); for the destructor of each class, there
   may be up to three variants (not counting virtual thunks): D0 and
   D1 destruct an instance of the class, including virtual base
   classes, but only the former calls operator delete to release the
   object's storage at the end; D2 destructs a sub-object (of the
   given class type) of an instance of a derived class (or a full
   object that doesn't have any virtual base classes).  new_decl
   expects to be called once for each constructor and destructor
   variant; the first time it sees a constructor or destructor with a
   given prototype, it will create the member declaration and all
   appropriate variants; then, and at subsequent calls for other
   variants, it will select the artificial clone declaration for the
   chosen variant, and set up the address or substitution name for
   that variant only.

   NAMEs for GCC_CP_FLAG_SPECIAL_FUNCTION:

     NAME    meaning
     C1      in-charge constructor
     C2      not-in-charge constructor
     D0      deleting destructor
     D1      in-charge destructor
     D2      not-in-charge destructor
     nw      operator new
     na      operator new[]
     dl      operator delete
     da      operator delete[]
     ps      operator + (unary)
     ng      operator - (unary)
     ad      operator & (unary)
     de      operator * (unary)
     co      operator ~
     pl      operator +
     mi      operator -
     ml      operator *
     dv      operator /
     rm      operator %
     an      operator &
     or      operator |
     eo      operator ^
     aS      operator =
     pL      operator +=
     mI      operator -=
     mL      operator *=
     dV      operator /=
     rM      operator %=
     aN      operator &=
     oR      operator |=
     eO      operator ^=
     ls      operator <<
     rs      operator >>
     lS      operator <<=
     rS      operator >>=
     eq      operator ==
     ne      operator !=
     lt      operator <
     gt      operator >
     le      operator <=
     ge      operator >=
     nt      operator !
     aa      operator &&
     oo      operator ||
     pp      operator ++
     mm      operator --
     cm      operator ,
     pm      operator ->*
     pt      operator ->
     cl      operator ()
     ix      operator []
     qu      operator ?
     cv      operator <T> (conversion operator)
     li<id>  operator "" <id>

   FIXME: we would benefit from a gcc_decl argument, to be able to
   introduce using declarations, using directives and namespace
   aliases.

   FIXME: How about attributes; static_assert; lambdas?  */

GCC_METHOD7 (gcc_decl, new_decl,
	     const char *,	      /* Argument NAME.  */
	     enum gcc_cp_symbol_kind, /* Argument SYM_KIND.  */
	     gcc_type,		      /* Argument SYM_TYPE.  */
	     const char *,	      /* Argument SUBSTITUTION_NAME.  */
	     gcc_address,	      /* Argument ADDRESS.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Return the type of a pointer to a given base type.  */

GCC_METHOD1 (gcc_type, build_pointer_type,
	     gcc_type)			/* Argument BASE_TYPE.  */

/* Return the type of a reference to a given base type.  */

GCC_METHOD2 (gcc_type, build_reference_type,
	     gcc_type,			/* Argument BASE_TYPE.  */
	     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */

/* Create a new pointer-to-member type.  MEMBER_TYPE is the data
   member type, while CLASS_TYPE is the class type containing the data
   member.  For pointers to member functions, MEMBER_TYPE must be a
   method type, and CLASS_TYPE must be specified even though it might
   be possible to extract it from the method type.  */

GCC_METHOD2 (gcc_type, build_pointer_to_member_type,
	     gcc_type,			   /* Argument CLASS_TYPE.  */
	     gcc_type) 			   /* Argument MEMBER_TYPE.  */

/* Create a new 'class' (or 'struct') type, record it in the current
   binding level, and enter its own binding level.  Initially it has
   no fields.

   NAME is the class name.  BASE_CLASSES indicate the base classes of
   class NAME.  FILENAME and LINE_NUMBER specify the source location
   associated with the class.  */

GCC_METHOD4 (gcc_type, start_new_class_type,
	     const char *,	      /* Argument NAME.  */
	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

// FIXME: do we need a flag to distinguish structs and classes?  This
// would be beneficial at least for error messages.

/* Create a new 'union' type, record it in the current binding level,
   and enter its own binding level.  Initially it has no fields.

   NAME is the union name.  FILENAME and LINE_NUMBER specify its
   source location.  */

GCC_METHOD3 (gcc_type, start_new_union_type,
	     const char *,	      /* Argument NAME.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Add a non-static data member to a struct or union type.  FIELD_NAME
   is the field's name.  FIELD_TYPE is the type of the field.  BITSIZE
   and BITPOS indicate where in the struct the field occurs.

   FIXME: how about mutable data members?  */

GCC_METHOD5 (int /* bool */, new_field,
	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
	     const char *,		   /* Argument FIELD_NAME.  */
	     gcc_type,			   /* Argument FIELD_TYPE.  */
	     unsigned long,		   /* Argument BITSIZE.  */
	     unsigned long)		   /* Argument BITPOS.  */

/* After all the fields have been added to a struct, class or union,
   the struct or union type must be "finished".  This does some final
   cleanups in GCC, and pops to the binding level that was in effect
   before the matching build_class_type or build_union_type.  */

GCC_METHOD2 (int /* bool */, finish_record_or_union,
	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
	     unsigned long)		   /* Argument SIZE_IN_BYTES.  */

/* Create a new 'enum' type, and record it in the current binding
   level.  The new type initially has no associated constants.

   NAME is the enum name.  FILENAME and LINE_NUMBER specify its source
   location.  */

GCC_METHOD5 (gcc_type, start_new_enum_type,
	     const char *,	      /* Argument NAME.  */
	     gcc_type,		      /* Argument UNDERLYING_INT_TYPE. */
	     int /* bool */,	      /* Argument SCOPED_ENUM_P.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Add a new constant to an enum type.  NAME is the constant's
   name and VALUE is its value.  */

GCC_METHOD3 (int /* bool */, build_add_enum_constant,
	     gcc_type,		       /* Argument ENUM_TYPE.  */
	     const char *,	       /* Argument NAME.  */
	     unsigned long)	       /* Argument VALUE.  */

/* After all the constants have been added to an enum, the type must
   be "finished".  This does some final cleanups in GCC.  */

GCC_METHOD1 (int /* bool */, finish_enum_type,
	     gcc_type)		       /* Argument ENUM_TYPE.  */

/* Create a new function type.  RETURN_TYPE is the type returned by
   the function, and ARGUMENT_TYPES is a vector, of length NARGS, of
   the argument types.  IS_VARARGS is true if the function is
   varargs.

   FIXME: default arguments?  */

GCC_METHOD3 (gcc_type, build_function_type,
	     gcc_type,			   /* Argument RETURN_TYPE.  */
	     const struct gcc_type_array *,/* Argument ARGUMENT_TYPES.  */
	     int /* bool */)		   /* Argument IS_VARARGS.  */

/* Create a variant of a function type with an exception
   specification.  FUNCTION_TYPE is a function or method type.
   EXCEPT_TYPES is an array with the list of exception types.  Zero as
   the array length implies throw() AKA noexcept(true); NULL as the
   pointer to gcc_type_array implies noexcept(false), which is almost
   equivalent (but distinguishable by the compiler) to an unspecified
   exception list.  */

GCC_METHOD2 (gcc_type, build_exception_spec_variant,
	     gcc_type,			   /* Argument FUNCTION_TYPE.  */
	     const struct gcc_type_array *)/* Argument EXCEPT_TYPES.  */

/* Create a new non-static member function type.  FUNC_TYPE is the
   method prototype, without the implicit THIS pointer, added as a
   pointer to the QUALS-qualified CLASS_TYPE.  If CLASS_TYPE is NULL,
   this creates a cv-qualified (member) function type not associated
   with any specific class, as needed to support "typedef void f(int)
   const;", which can later be used to declare member functions and
   pointers to member functions.  */

GCC_METHOD4 (gcc_type, build_method_type,
	     gcc_type,			   /* Argument CLASS_TYPE.  */
	     gcc_type, 			   /* Argument FUNC_TYPE.  */
	     enum gcc_cp_qualifiers,	   /* Argument QUALS.  */
	     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */

// FIXME: add default expressions for function arguments?

/* Return an integer type with the given properties.  */

GCC_METHOD2 (gcc_type, int_type,
	     int /* bool */,		   /* Argument IS_UNSIGNED.  */
	     unsigned long)                /* Argument SIZE_IN_BYTES.  */

/* Return a floating point type with the given properties.  */

GCC_METHOD1 (gcc_type, float_type,
	     unsigned long)			/* Argument SIZE_IN_BYTES.  */

/* Return the 'void' type.  */

GCC_METHOD0 (gcc_type, void_type)

/* Return the 'bool' type.  */

GCC_METHOD0 (gcc_type, bool_type)

/* Create a new array type.  If NUM_ELEMENTS is -1, then the array
   is assumed to have an unknown length.  */

GCC_METHOD2 (gcc_type, build_array_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     int)			  /* Argument NUM_ELEMENTS.  */

/* Create a new variably-sized array type.  UPPER_BOUND_NAME is the
   name of a local variable that holds the upper bound of the array;
   it is one less than the array size.  */

GCC_METHOD2 (gcc_type, build_vla_array_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     const char *)		  /* Argument UPPER_BOUND_NAME.  */

/* Return a qualified variant of a given base type.  QUALIFIERS says
   which qualifiers to use; it is composed of or'd together
   constants from 'enum gcc_cp_qualifiers'.  */

GCC_METHOD2 (gcc_type, build_qualified_type,
	     gcc_type,			      /* Argument UNQUALIFIED_TYPE.  */
	     enum gcc_cp_qualifiers)	      /* Argument QUALIFIERS.  */

/* Build a complex type given its element type.  */

GCC_METHOD1 (gcc_type, build_complex_type,
	     gcc_type)			  /* Argument ELEMENT_TYPE.  */

/* Build a vector type given its element type and number of
   elements.  */

GCC_METHOD2 (gcc_type, build_vector_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     int)			  /* Argument NUM_ELEMENTS.  */

/* Build a constant.  NAME is the constant's name and VALUE is its
   value.  FILENAME and LINE_NUMBER refer to the type's source
   location.  If this is not known, FILENAME can be NULL and
   LINE_NUMBER can be 0.  */

GCC_METHOD5 (int /* bool */, build_constant,
	     gcc_type,		  /* Argument TYPE.  */
	     const char *,	  /* Argument NAME.  */
	     unsigned long,	  /* Argument VALUE.  */
	     const char *,	  /* Argument FILENAME.  */
	     unsigned int)	  /* Argument LINE_NUMBER.  */

/* Emit an error and return an error type object.  */

GCC_METHOD1 (gcc_type, error,
	     const char *)		 /* Argument MESSAGE.  */
